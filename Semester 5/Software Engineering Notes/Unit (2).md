# Unit 2: Software Life Cycle Models

The **Software Life Cycle** is a structured approach to software development, which defines the stages through which software passes from initial concept to final release and maintenance. Different life cycle models help manage the development process, ensuring that projects are completed efficiently, on time, and within budget. These models are frameworks that describe the phases involved in software development.

---

#### **2.1 Requirement of Life Cycle Model**
A Software Life Cycle Model provides the following benefits:
- **Structure and Organization**: It provides a clear structure for managing a project, outlining what needs to be done in each phase.
- **Efficient Management**: Helps manage time, resources, costs, and quality in a systematic way.
- **Risk Management**: Anticipates risks early, allowing mitigation strategies.
- **Quality Assurance**: Ensures that quality is maintained through defined stages.
- **Customer Satisfaction**: Keeps the customer involved and informed throughout the project.

A life cycle model is required to:
- Ensure clarity and control in the development process.
- Provide feedback mechanisms to allow refinement of the product.
- Help manage project resources efficiently.
- Reduce risks associated with changes in project scope or requirements.

---

#### **2.2 Classic Waterfall Model**
The **Waterfall Model** is one of the simplest and most well-known software development life cycle models. It is a linear and sequential approach, where each phase is completed before the next one begins.

**Phases** of the Waterfall Model:
1. **Requirement Analysis**: Gathering and defining the system requirements.
2. **System Design**: Designing the system architecture and components.
3. **Implementation**: Writing the code for the system.
4. **Testing**: Verifying that the software meets the defined requirements and is free of defects.
5. **Deployment**: Installing the system in the live environment.
6. **Maintenance**: Ongoing support and updates.

**Advantages**:
- Simple and easy to understand.
- Well-suited for smaller projects with clearly defined requirements.
- Easy to manage due to its linear structure.

**Disadvantages**:
- Inflexible for changes once the project starts.
- Customer feedback is incorporated only after the testing phase.
- Difficult to handle complex or unclear requirements.

---

#### **2.3 Prototyping Model**
The **Prototyping Model** is used when the requirements are not well understood or unclear. It involves creating a prototype (an early version of the software) to gather user feedback and refine requirements.

**Phases** of the Prototyping Model:
1. **Requirement Identification**: Define basic system requirements.
2. **Prototype Development**: Develop a prototype based on initial requirements.
3. **User Evaluation**: Present the prototype to users and gather feedback.
4. **Refinement**: Modify the prototype based on user feedback and repeat steps 3 and 4 until the system meets user needs.
5. **Final System Development**: Develop the final system based on the refined prototype.

**Advantages**:
- Helps in handling unclear or evolving requirements.
- Provides early user feedback.
- Reduces the risk of major rework later in the project.

**Disadvantages**:
- Prototypes may not always be of high quality.
- The process may become iterative and time-consuming.
- Potential for user confusion as the prototype may not reflect the final product.

---

#### **2.4 Evolutionary Model**
The **Evolutionary Model** focuses on producing a functional system early in the development and then refining and expanding it through multiple iterations (evolutions). It is more flexible and adaptive to changes in requirements.

**Phases** of the Evolutionary Model:
1. **Initial Development**: Build a simple, working version of the system.
2. **Iterative Refinement**: Continue to refine and enhance the system in cycles based on user feedback.
3. **Final System Development**: Finalize the system after several iterations.

**Advantages**:
- Suitable for large, complex systems with changing requirements.
- Early delivery of partial working systems.
- Flexible to changes and can adapt to evolving user needs.

**Disadvantages**:
- May lead to scope creep if changes are not controlled.
- Can be difficult to track progress and manage expectations.
- Potential for poor architecture due to rapid changes.

---

#### **2.5 Spiral Model**
The **Spiral Model** combines elements of both iterative development and the waterfall model. It emphasizes risk management and continuous refinement through multiple cycles.

**Phases** of the Spiral Model:
1. **Planning**: Define objectives, alternatives, and constraints.
2. **Risk Analysis**: Identify and assess risks associated with the project.
3. **Engineering**: Develop and test the software.
4. **Evaluation**: Review the progress with stakeholders and decide whether to continue or revise the plan.
5. **Next Iteration**: Continue refining the software through additional iterations.

**Advantages**:
- Focuses on risk management, reducing project risks.
- Allows flexibility and iteration, making it suitable for large and complex projects.
- Continuous user feedback.

**Disadvantages**:
- Can be complex to manage due to its iterative nature.
- Requires expertise in risk analysis.
- Potentially higher costs due to repeated iterations.

---

#### **2.6 Introduction to Agile Methodology**
**Agile** is an iterative and incremental software development methodology that emphasizes flexibility, collaboration, and customer feedback. Agile focuses on delivering small, functional pieces of the software quickly and frequently, rather than waiting until the end of the project.

**Key Principles of Agile**:
- Delivering working software frequently.
- Welcoming changing requirements, even late in development.
- Collaborating with customers and stakeholders.
- Fostering a sustainable development pace.
- Emphasizing individuals and interactions over processes and tools.

**Popular Agile Frameworks**:
- **Scrum**: A framework for managing agile projects with defined roles (e.g., Scrum Master, Product Owner) and iterative sprints.
- **Kanban**: A visual method to manage and optimize the flow of work through a system.
- **Extreme Programming (XP)**: Focuses on technical excellence and frequent releases.

**Advantages**:
- Flexibility to change requirements during the development process.
- Close collaboration with customers and stakeholders.
- Quick delivery of working software.

**Disadvantages**:
- Can be difficult to scale for large projects.
- May lead to lack of documentation and incomplete specifications.
- Requires a high level of customer involvement.

---

#### **2.7 Comparison of Different Life Cycle Models**

| **Model**            | **Description**                      | **Advantages**                                          | **Disadvantages**                                      |
|----------------------|--------------------------------------|---------------------------------------------------------|--------------------------------------------------------|
| **Waterfall**         | Linear and sequential approach.      | Simple, easy to manage, good for small projects.        | Inflexible to changes, customer feedback only later.   |
| **Prototyping**       | Builds a prototype for user feedback.| Useful for unclear or evolving requirements.           | May lead to user confusion, prototype may not be final. |
| **Evolutionary**      | Iterative development and refinement.| Flexible to changing requirements, early system delivery.| Scope creep, difficult to manage expectations.         |
| **Spiral**            | Combines waterfall and iterative model with focus on risk. | Risk management, flexibility for large projects.         | Complex to manage, high costs due to repeated cycles.   |
| **Agile**             | Iterative, incremental development with customer collaboration. | Flexible, fast delivery, continuous feedback.            | May lack comprehensive documentation, challenging for large projects. |

---

